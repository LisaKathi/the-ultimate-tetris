#pragma checksum "C:\Freizeit\Tetris\BlazorTetris\Pages\Index.cshtml" "{ff1816ec-aa5e-4d10-87f7-6f4963833460}" "7eab59fe92899f629d9457f0c93a38ab8893bbe5"
// <auto-generated/>
#pragma warning disable 1591
#pragma warning disable 0414
#pragma warning disable 0649
#pragma warning disable 0169

namespace BlazorTetris.Pages
{
    #line hidden
    using System;
    using System.Collections.Generic;
    using System.Linq;
    using System.Threading.Tasks;
    using Microsoft.AspNetCore.Blazor;
    using Microsoft.AspNetCore.Blazor.Components;
    using System.Net.Http;
    using Microsoft.AspNetCore.Blazor.Layouts;
    using Microsoft.AspNetCore.Blazor.Routing;
    using Microsoft.JSInterop;
    using BlazorTetris;
    using BlazorTetris.Shared;
    using BlazorTetris.Logic;
    [Microsoft.AspNetCore.Blazor.Layouts.LayoutAttribute(typeof(MainLayout))]

    [Microsoft.AspNetCore.Blazor.Components.RouteAttribute("/")]
    public class Index : Microsoft.AspNetCore.Blazor.Components.BlazorComponent, IDisposable
    {
        #pragma warning disable 1998
        protected override void BuildRenderTree(Microsoft.AspNetCore.Blazor.RenderTree.RenderTreeBuilder builder)
        {
        }
        #pragma warning restore 1998
#line 34 "C:\Freizeit\Tetris\BlazorTetris\Pages\Index.cshtml"
            
    private const int ROWS = 16;
    private const int COLUMNS = 10;
   

    private string[,] board;
    private bool lost = false;

    private string[,] currentPiece = null;
    private (int x, int y) currentPiecePosition = (0, 0);

    static event EventHandler<int>
    LeftRightPressed;

    [JSInvokable]
    public static void LeftRightPressedJS(int direction)
    {
    Console.WriteLine(direction);
    LeftRightPressed?.Invoke(null, direction);
    }

    protected override void OnInit()
    {
    InitializeBoard();
    GameLoopAsync();

    LeftRightPressed += HandleArrowKey;
    }

    public void Dispose()
    {
    LeftRightPressed -= HandleArrowKey;
    }
    private void HandleArrowKey(object _, int direction)
    {
    var moved = false;
    RemoveCurrentPiece();
    var newX = currentPiecePosition.x + direction;
    if (newX >= 0 && (newX + currentPiece.GetLength(1)) <= COLUMNS && IsPositionPossible((newX, currentPiecePosition.y)))
    {
    currentPiecePosition.x = newX;
    moved = true;
    }
    DrawCurrentPiece();
    if (moved)
    {
    StateHasChanged();
    }
    }

    private async void GameLoopAsync()
    {
    NewPiece();
    do
    {
    DrawCurrentPiece();
    StateHasChanged();

    await Task.Delay(400);

    RemoveCurrentPiece();

    if (currentPiecePosition.y + currentPiece.GetLength(0) < ROWS &&
    IsPositionPossible((currentPiecePosition.x, currentPiecePosition.y + 1)))
    {

    currentPiecePosition.y++;
    }
    else
    {
    DrawCurrentPiece();
    NewPiece();
    if (!IsPositionPossible(currentPiecePosition))
    {
    lost = true;
    }
    }
    }
    while (!lost);
    StateHasChanged();
    }

    private void RemoveCurrentPiece() => currentPiece.Iterate((row, col) =>
    {
    if (currentPiece[row, col] != string.Empty)
    {
    board[currentPiecePosition.y + row, currentPiecePosition.x + col] = string.Empty;
    }
    });
    private void DrawCurrentPiece() => currentPiece.Iterate((row, col) =>
    {
    if (currentPiece[row, col] != string.Empty)
    {
    board[currentPiecePosition.y + row, currentPiecePosition.x + col] =
    currentPiece[row, col];
    }


    });



    private void NewPiece()
    {
    currentPiece = Pieces.GetRandomPiece();
    currentPiecePosition.y = 0;
    currentPiecePosition.x = (COLUMNS - currentPiece.GetLength(1)) / 2;
    }
    private void InitializeBoard()
    {
    board = new string[ROWS, COLUMNS];
    board.Iterate((row, col) => board[row, col] = string.Empty);
    }

    private bool IsPositionPossible((int x, int y) target) =>
    currentPiece.Iterate((row, col) => currentPiece[row, col] == string.Empty || board[target.y + row, target.x + col] == string.Empty);


    

#line default
#line hidden
    }
}
#pragma warning restore 1591
